% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glvmlss.R
\name{glvmlss_sim}
\alias{glvmlss_sim}
\title{Simulate data for a Generalized latent variable model for location, scale, and shape parameters}
\usage{
glvmlss_sim <- function(n, family,
                        mu.eq = ~ Z1, sg.eq = NULL,
                        nu.eq = NULL, ta.eq = NULL,
                        control = list(), ...)
}
\arguments{
\item{n}{Number of simulated entries.}

\item{family}{String vector of size \code{p} with family for each observed variable.}

\item{mu.eq}{Formula for location parameter e.g.,  \code{mu.eq = ~ Z1}.}

\item{sg.eq}{(optional) Formula for scale parameter.}

\item{nu.eq}{(optional) Formula for shape parameter.}

\item{ta.eq}{(optional) Formula for shape parameter.}

\item{control}{List of control parameters (see 'Details').}

\item{...}{Further arguments to be passed to \code{control}.}
}
\value{
A list with components:
\itemize{
\item \code{Y}: A matrix \code{(n x p)} of observed variables, each column from a distribution specified in \code{family}.
\item \code{Z}: Simulated latent variables (includes a column corresponding to the intercept).
\item \code{b}: An array of true coefficients.
\item \code{R}: A matrix \code{(q x q)} of true factor covariances.
}
}
\description{
Simulate data for a Generalized latent variable model for location, scale, and shape parameters
}
\details{
The current implementation allows only for the following entries in the string vector \code{family} : \code{"normal"} (for Gaussian items),
\code{"binomial"} (for binary items, fixed \code{size = 1}), \code{"beta"} (for Beta distributed items), and \code{"sn"} (for Skew-Normal items).
More distributions will be continuously added as users require them.

The \code{control} argument is a list that can supply any of the following components:
\itemize{
\item \code{corLV} (bool): The latent variables are correlated. Defaults to \code{corLV = F}.
\item \code{start.b} (array): \code{[MANDATORY]} An array \code{(p x (q+1) x d)} of true values for the intercepts and factor loadings. \code{p} refers
to the number of items, \code{q} to the number of latent variables, and \code{d} to the total number of distributional parameters.
\item \code{start.R} (matrix): A matrix \code{(q x q)} for the covariance matrix of the latent variables.
If the argument is not provided (i.e., \code{start.R = NULL} by default),
it defaults to \code{diag(start.R) = 1.1} if \code{control$corLV = F}. If \code{start.R = NULL} and \code{control$corLV = T}, the diagonal elements are
initialized to 1.1 and the off-diagonal elements are initialized to 0.3.
\item \code{restr.b} (array): An array \code{(p x (q+1) x d)} of restrictions on the intercepts and factor loadings. Free parameters
(i.e., to be estimated) are encoded by \code{NA}, while fixed parameters must take some value (e.g., fixed factor loading with value 1
for item 1, latent variable 1, and location parameter is \code{start.b[1,2,1] = 1}).
If the argument is not provided, restrictions are implicitly derived from the argument \code{start.b}.
\item \code{restr.R} (matrix): A matrix \code{(q x q)} of restrictions on the latent variable covariances. Typical restrictions include
fixed variances with value equal to one (e.g., \code{start.R[1,1] = 1}), or fixed covariances with value equal to zero (e.g. \code{start.R[1,2] = 0}).
}

The argument \code{...} can be used to pass elements directly to the list \code{control}, without explicitly defining the latter.
}
\examples{
library(glvmlss)

# Simulate data following the PISA2018 application
# in Cárdenas-Hurtado et al. (2025)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Eight (8) Skew-Normal response times and eight (8) binary items
p = 8
faml = c(rep("sn",p),rep("binomial",p))

# Population (true) factor loadings
lc = array(0,dim = c(2*p,3,3))
lc[1:p,1,1] <- c( .19,  .30,  .42,  .45, 1.00,  .16,  .65,  .58)
lc[1:p,2,1] <- c(-.17, -.24, -.25, -.34, -.36, -.36, -.35, -.30)
lc[1:p,1,2] <- c(-.95, -.89, -.61, -.87, -.68, -.97,-1.15, -.90)
lc[1:p,2,2] <- c( .03,  .10,  .08,  .05, -.14, -.03,  .04,  .02)
lc[1:p,1,3] <- c( .63, 1.56,-1.07,-1.45,-1.04,  .10,  .36,  .30)
lc[1:p,2,3] <- c( .03,  .78, -.81,  .33,  .32,  .89,  .58, -.36)
lc[(p+1):(2*p),1,1] <- c( .64, -.47, -.04, -.69,-2.85, -.91,-4.84,-2.73)
lc[(p+1):(2*p),3,1] <- c( .78, 1.03, 1.95,  .96, 2.28,  .32, 2.53, 1.46)

# Population (true) factor correlation matrix
R <- matrix(c(1,-0.28,-0.28,1),2)

# Identification restrictions
ires <- array(NA,dim = c(2*p,3,3))
ires[1:p,3,1:3] <- 0
ires[(p+1):(2*p),2,1] <- 0
ires[(p+1):(2*p),,2:3] <- 0

# Sample size
n = 3000

# Simulate data
mod0 <- glvmlss::glvmlss_sim(n = n, family = faml, mu.eq = ~ Z1+Z2, sg.eq = ~ Z1+Z2, nu.eq = ~ Z1+Z2,
                             start.b = lc, start.R = R,
                             restr.b = ires, restr.R = matrix(c(1,NA,NA,1),2))
\dontrun{
# Fit the model:
mod1 <- glvmlss::glvmlss(data = mod0$Y,family = faml,mu.eq = ~ Z1+Z2, sg.eq = ~ Z1+Z2, nu.eq = ~ Z1+Z2,
                         EM.useGD = T, LR = 0.0001,
                         EM.maxit = 500, DM.maxit = 1000, nQP = 35, verbose = T,
                         corLV = T, tolerance = 1e-5, start.b = mod0$b, start.R = mod0$R,
                         restr.b = ires, restr.R = matrix(c(1,NA,NA,1),2), sign.restr.b = c(-1,2))
}
}
\author{
Camilo Cárdenas-Hurtado (\email{c.a.cardenas-hurtado@lse.ac.uk}).
}
